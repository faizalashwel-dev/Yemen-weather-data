<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MET-ANALYTICS COMMAND CENTER // YEMEN</title>
    <!-- STABLE LIBS -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0"></script>
    <!-- MAP ENGINE -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root {
            --bg: #020202;
            --panel: #0a0a0a;
            --accent: #00ffff;
            --border: #1a1a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Consolas', monospace;
            color: #fff;
        }

        body {
            background: var(--bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            overflow-y: auto;
        }

        header {
            height: 50px;
            border-bottom: 2px solid var(--accent);
            display: flex;
            align-items: center;
            padding: 0 20px;
            background: #000;
            z-index: 100;
            justify-content: space-between;
        }

        .layout {
            flex: 1;
            display: grid;
            grid-template-columns: 260px 1fr;
        }

        .sidebar {
            background: #050505;
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }

        .city-item {
            padding: 12px 15px;
            border-bottom: 1px solid #111;
            cursor: pointer;
            transition: 0.1s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .city-item:hover {
            background: #0a0a0a;
            border-left: 2px solid var(--accent);
        }

        .city-item.active {
            background: #111;
            border-left: 4px solid var(--accent);
        }

        .main-stage {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            height: 100%;
        }

        .top-deck {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 12px;
            height: 350px;
            min-height: 350px;
        }

        .stats-col {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 10px;
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-radius: 4px;
            border-left: 3px solid #333;
            transition: 0.3s;
        }

        .card:hover {
            border-left-color: var(--accent);
            background: #111;
        }

        .card .label {
            font-size: 0.6rem;
            color: #555;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .card .val {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: bold;
        }

        .map-wrapper {
            background: var(--panel);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            height: 100%;
            border-radius: 4px;
        }

        .map-scanner {
            position: absolute;
            top: 0;
            left: -100%;
            width: 40%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.2), transparent);
            pointer-events: none;
            z-index: 1000;
            animation: scan 10s linear infinite;
            filter: blur(4px);
        }

        @keyframes scan {
            0% {
                left: -100%;
            }

            100% {
                left: 150%;
            }
        }

        canvas.wind-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1500;
        }

        #map {
            height: 100%;
            width: 100%;
            background: #000;
        }

        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1.2fr 1fr;
            gap: 12px;
            height: 260px;
            min-height: 260px;
        }

        .chart-wrap {
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 8px;
            position: relative;
            height: 100%;
            overflow: hidden;
            border-radius: 4px;
        }

        .timeline-box {
            height: 180px;
            min-height: 180px;
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 8px;
            overflow: hidden;
            border-radius: 4px;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #sync-tag {
            font-size: 0.7rem;
            color: #0f0;
        }

        .error-banner {
            background: #f00;
            color: #fff;
            padding: 5px;
            text-align: center;
            position: fixed;
            top: 0;
            width: 100%;
            display: none;
            z-index: 1000;
        }

        /* Tactical Tooltip Style */
        .tactical-tooltip {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid var(--accent);
            color: var(--accent);
            font-family: 'Consolas', monospace;
            padding: 5px 10px;
            font-size: 0.75rem;
            border-radius: 0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .leaflet-tooltip-pane {
            z-index: 650;
        }

        .marker-pulse {
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        /* INFO ICON ENGINE */
        .info-icon {
            position: absolute;
            top: 5px;
            right: 8px;
            width: 14px;
            height: 14px;
            background: #333;
            border: 1px solid #555;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: help;
            font-size: 10px;
            font-weight: bold;
            color: var(--accent);
            z-index: 1001;
            transition: 0.2s;
        }

        .info-icon:hover {
            background: var(--accent);
            color: #000;
            border-color: #fff;
        }

        .info-box {
            position: absolute;
            top: 25px;
            right: 0;
            width: 220px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid var(--accent);
            padding: 10px;
            font-size: 0.7rem;
            line-height: 1.3;
            color: #ddd;
            display: none;
            z-index: 2000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
            border-radius: 4px;
        }

        .info-icon:hover+.info-box {
            display: block;
        }

        .info-box b {
            color: var(--accent);
            display: block;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.75rem;
        }

        /* SIDE DRAWER STYLES */
        .menu-btn {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.3s;
            margin-right: 15px;
        }

        .menu-btn:hover {
            text-shadow: 0 0 10px var(--accent);
        }

        .drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .drawer-overlay.active {
            display: block;
            opacity: 1;
        }

        .drawer {
            position: fixed;
            top: 0;
            left: -300px;
            width: 300px;
            height: 100%;
            background: #050505;
            border-right: 2px solid var(--accent);
            z-index: 2001;
            transition: left 0.3s ease-in-out;
            padding: 20px;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
        }

        .drawer.active {
            left: 0;
        }

        .drawer-header {
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .drawer-title {
            color: var(--accent);
            font-size: 0.9rem;
            letter-spacing: 2px;
        }

        .close-drawer {
            background: none;
            border: none;
            color: #555;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .close-drawer:hover {
            color: var(--accent);
        }

        .drawer-nav {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .nav-link {
            text-decoration: none;
            color: #aaa;
            font-size: 1rem;
            padding: 10px;
            border-left: 2px solid transparent;
            transition: 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-link:hover,
        .nav-link.active {
            color: #fff;
            background: #111;
            border-left-color: var(--accent);
        }

        .nav-link b {
            color: var(--accent);
            font-size: 0.8rem;
        }
    </style>
</head>

<body>
    <div id="api-error" class="error-banner">OFFLINE: NO CONNECTION TO BACKEND SERVER</div>
    <header>
        <div style="display: flex; align-items: center;">
            <button class="menu-btn" id="drawer-toggle">☰</button>
            <div class="logo">ATMOS-ALPHA // TACTICAL_ISR_GRID v11.0</div>
        </div>
        <div id="sync-tag" class="sync-tag">CONNECTING_LINK...</div>
    </header>

    <div class="drawer-overlay" id="drawer-overlay"></div>
    <div class="drawer" id="drawer">
        <div class="drawer-header">
            <div class="drawer-title">COMMAND_MENU</div>
            <button class="close-drawer" id="drawer-close">✕</button>
        </div>
        <nav class="drawer-nav">
            <a href="/" class="nav-link active"><b>01</b> WEATHER_DASHBOARD</a>
            <a href="/health" class="nav-link"><b>02</b> HEALTH_SECTOR</a>
            <a href="/education" class="nav-link"><b>03</b> EDUCATION_INTEL</a>
        </nav>
    </div>

    <div class="layout">
        <div class="sidebar" id="city-sidebar"></div>
        <div class="main-stage">

            <div class="top-deck">
                <div class="stats-col">
                    <div class="card">
                        <div class="label">TEMPERATURE</div>
                        <div class="val" id="st-temp">--</div>
                    </div>
                    <div class="card">
                        <div class="label">HUMIDITY</div>
                        <div class="val" id="st-hum">--</div>
                    </div>
                    <div class="card">
                        <div class="label">BARO_PRESSURE</div>
                        <div class="val" id="st-pres">--</div>
                    </div>
                    <div class="card">
                        <div class="label">VISIBILITY</div>
                        <div class="val" id="st-vis">--</div>
                    </div>
                </div>
                <div class="map-wrapper">
                    <div class="map-scanner"></div>
                    <div id="map"></div>
                </div>
            </div>

            <div class="charts-row">
                <div class="chart-wrap">
                    <div style="font-size:0.6rem; color:#444; margin-bottom:3px;">ATMOSPHERIC RADAR PROFILING</div>
                    <div class="info-icon">!</div>
                    <div class="info-box">
                        <b>Radar Scan</b>
                        A multi-factor weather analysis. The shape grows as conditions like high heat, strong wind, or
                        humidity become more intense in the selected city.
                    </div>
                    <canvas id="radarChart"></canvas>
                </div>
                <div class="chart-wrap">
                    <div style="font-size:0.6rem; color:#444; margin-bottom:3px;">REGIONAL UV THREAT SPECTRUM</div>
                    <div class="info-icon">!</div>
                    <div class="info-box">
                        <b>UV Spectrum</b>
                        Measures solar radiation across Yemen. Large colored segments indicate dangerous UV levels that
                        require sun protection.
                    </div>
                    <canvas id="polarChart"></canvas>
                </div>
                <div class="chart-wrap">
                    <div style="font-size:0.6rem; color:#444; margin-bottom:3px;">REGIONAL CLOUD_DENSITY (OCTANTS)</div>
                    <div class="info-icon">!</div>
                    <div class="info-box">
                        <b>Cloud Coverage</b>
                        Compares sky density across different regions. Higher bars mean more overcast conditions, while
                        low bars mean clear skies.
                    </div>
                    <canvas id="barChart"></canvas>
                </div>
            </div>

            <div class="timeline-box" style="position:relative;">
                <div style="font-size:0.6rem; color:#444; margin-bottom:3px;">TEMPORAL ENERGY GRADIENT (3H WINDOW)</div>
                <div class="info-icon" style="top:8px; right:12px;">!</div>
                <div class="info-box" style="top:28px; right:8px;">
                    <b>Temperature Trend</b>
                    A historical log showing how the temperature has climbed or dropped over the last few hours for the
                    main cities.
                </div>
                <canvas id="lineChart"></canvas>
            </div>
        </div>
    </div>

    <style>
        /* MOBILE OPTIMIZATIONS (RESPONSIVE ENGINE) */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                height: auto;
            }

            .logo {
                font-size: 0.7rem;
            }

            .layout {
                grid-template-columns: 1fr;
                height: auto;
            }

            .sidebar {
                border-right: none;
                border-bottom: 2px solid var(--accent);
                max-height: none;
                order: 1;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 5px;
                padding: 10px;
                background: #000;
            }

            .city-item {
                flex-direction: column;
                justify-content: center;
                text-align: center;
                padding: 8px 5px;
                background: var(--panel);
                border: 1px solid var(--border);
                border-radius: 4px;
                min-height: 70px;
                border-bottom: 1px solid var(--border);
            }

            .city-item span {
                display: block;
                font-size: 0.7rem;
                margin-bottom: 4px;
            }

            .city-item.active {
                border: 1px solid var(--accent);
                border-left: 1px solid var(--accent);
                background: #111;
            }

            .main-stage {
                padding: 10px;
                order: 2;
                height: auto;
                overflow: visible;
            }

            .top-deck {
                grid-template-columns: 1fr;
                height: auto;
                min-height: auto;
            }

            .stats-col {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 5px;
            }

            .card {
                padding: 8px;
                height: 60px;
            }

            .card .val {
                font-size: 1rem;
            }

            .map-wrapper {
                height: 300px;
                min-height: 300px;
            }

            .charts-row {
                grid-template-columns: 1fr;
                height: auto;
                min-height: auto;
                gap: 10px;
            }

            .chart-wrap {
                height: 240px;
            }

            .timeline-box {
                height: 220px;
            }

            .info-box {
                width: calc(100vw - 40px);
                max-width: 280px;
                right: 0;
                left: auto;
                top: 30px;
            }
        }
    </style>

    <script>
        let selectedId = null;
        let instances = {};
        let map, geoLayer, markers = {};
        const GEO_URL = 'https://media.githubusercontent.com/media/wmgeolab/geoBoundaries/main/releaseData/gbOpen/YEM/ADM1/geoBoundaries-YEM-ADM1.geojson';

        // ENHANCED NAME MAPPING FOR GEOJSON SYNCHRONIZATION
        const NAME_MAP = {
            "Amran Governorate": "Amran",
            "Abyan Governorate": "Abyan",
            "Ad Dali' Governorate": "Al Dali'",
            "Al Bayda' Governorate": "Al Bayda'",
            "Al Hudaydah Governorate": "Al Hudaydah",
            "Al Jawf Governorate": "Al Jawf",
            "Al Mahrah Governorate": "Al Mahrah",
            "Al Mahwit Governorate": "Al Mahwit",
            "Dhamar Governorate": "Dhamar",
            "Hadhramaut": "Mukalla",
            "Hajjah Governorate": "Hajjah",
            "Ibb Governorate": "Ibb",
            "Lahij Governorate": "Lahij",
            "Ma'rib Governorate": "Ma'rib",
            "Raymah Governorate": "Raymah",
            "Sa'dah Governorate": "Sa'dah",
            "Sanʿaʾ": "Sana'a",
            "Sanʿaʾ Governorate": "Sana'a",
            "Shabwah Governorate": "Shabwah",
            "Ta'izz Governorate": "Taiz",
            "‘Adan Governorate": "Aden",
            "Amanat Al Asimah": "Sana'a"
        };

        function normalizeName(n) {
            return n.replace(/Governorate/g, '').replace(/[ʿ‘]|['`]/g, '').trim().toLowerCase();
        }

        function getTempColor(t) {
            if (!t && t !== 0) return '#222';
            if (t > 33) return '#ff3300';
            if (t > 27) return '#ff9900';
            if (t > 20) return '#00ffff';
            if (t > 14) return '#0088ff';
            return '#0044ff';
        }

        // TACTICAL UTILITY: POINT-IN-POLYGON CHECK
        function isPointInPolygon(latlng, layer) {
            if (!layer || !layer.getBounds().contains(latlng)) return false;

            const latlngs = layer.getLatLngs();
            // Handle MultiPolygon and Holes (Flatten to array of rings)
            const rings = layer instanceof L.MultiPolygon || Array.isArray(latlngs[0]) ?
                (Array.isArray(latlngs[0]) && !Array.isArray(latlngs[0][0]) ? [latlngs] : latlngs) :
                [latlngs];

            let inside = false;
            const x = latlng.lat, y = latlng.lng;

            for (let i = 0; i < rings.length; i++) {
                let ring = rings[i];
                if (Array.isArray(ring[0]) || ring[0] instanceof L.LatLng) {
                    // Normalize ring (Latlng list)
                    const coords = (ring[0] instanceof L.LatLng) ? ring : ring[0];
                    for (let j = 0, k = coords.length - 1; j < coords.length; k = j++) {
                        const xi = coords[j].lat, yi = coords[j].lng;
                        const xj = coords[k].lat, yj = coords[k].lng;
                        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }
                }
            }
            return inside;
        }

        let windEngine = null;
        class WindEngine {
            constructor(map) {
                this.map = map;
                this.canvas = document.createElement('canvas');
                this.canvas.className = 'wind-layer';
                document.querySelector('.map-wrapper').appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.data = [];
                this.govLayers = {}; // To be populated by initMap

                window.addEventListener('resize', () => this.resize());
                map.on('move moveend zoomend', () => this.resize());
                this.resize();
                this.loop();
            }
            resize() {
                const rect = this.map.getContainer().getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.particles = []; // Clear to avoid ghosting
            }
            update(cities) {
                this.data = cities.filter(c => c.windspeed > 0);
            }
            loop() {
                // FADE TRAILS WITHOUT ADDING BLACK (fixes the "dark map" bug)
                this.ctx.globalCompositeOperation = 'destination-out';
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.globalCompositeOperation = 'source-over';

                // Spawn (STICKY TO GOVERNORATES)
                if (this.particles.length < 500 && this.data.length > 0) {
                    for (let i = 0; i < 4; i++) {
                        const city = this.data[Math.floor(Math.random() * this.data.length)];
                        const layer = this.govLayers[city.city_name];
                        if (!layer) continue;

                        const pt = this.map.latLngToContainerPoint([city.latitude, city.longitude]);
                        this.particles.push({
                            x: pt.x + (Math.random() - 0.5) * 50,
                            y: pt.y + (Math.random() - 0.5) * 50,
                            v: city.windspeed * 0.15 + 0.5,
                            a: (city.winddirection - 90) * Math.PI / 180,
                            life: 1.0 + Math.random() * 0.5,
                            layer: layer
                        });
                    }
                }
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 4;
                this.ctx.shadowColor = '#0ff';

                this.particles.forEach((p, i) => {
                    const dx = Math.cos(p.a) * p.v;
                    const dy = Math.sin(p.a) * p.v;

                    // Check Boundary Constraint
                    const nextX = p.x + dx;
                    const nextY = p.y + dy;
                    const latlng = this.map.containerPointToLatLng([nextX, nextY]);

                    if (!isPointInPolygon(latlng, p.layer)) {
                        p.life = 0; // Destroy if boundary hit
                    }

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = `rgba(0, 255, 255, ${p.life * 0.8})`;
                    this.ctx.moveTo(p.x, p.y);
                    p.x = nextX; p.y = nextY;
                    this.ctx.lineTo(p.x, p.y);
                    this.ctx.stroke();
                    p.life -= 0.012;
                    if (p.life <= 0) this.particles.splice(i, 1);
                });
                this.ctx.shadowBlur = 0; // Reset for performance

                requestAnimationFrame(() => this.loop());
            }
        }

        async function initMap() {
            if (map) return;
            map = L.map('map', { zoomControl: false, attributionControl: false }).setView([15.5, 48.0], 6);

            // CLEAN DARK TILES
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

            // FETCH TACTICAL SHADING (Governorates)
            try {
                const res = await fetch(GEO_URL);
                const geoData = await res.json();

                geoLayer = L.geoJSON(geoData, {
                    style: feature => {
                        const govName = feature.properties.shapeName;
                        const mappedName = NAME_MAP[govName] || govName;
                        const normGov = normalizeName(govName);

                        const city = lastData.find(c =>
                            c.city_name === mappedName ||
                            normalizeName(c.city_name) === normGov
                        );

                        return {
                            fillColor: city ? getTempColor(city.temperature) : '#111',
                            weight: city ? 2.5 : 1,
                            opacity: 1,
                            color: city ? '#fff' : '#333',
                            fillOpacity: city ? 0.6 : 0.05,
                            transition: '0.4s'
                        };
                    },
                    onEachFeature: (feature, layer) => {
                        const govName = feature.properties.shapeName;
                        const mappedName = NAME_MAP[govName] || govName;
                        const normGov = normalizeName(govName);

                        layer.on({
                            mouseover: (e) => {
                                const city = lastData.find(c =>
                                    c.city_name === mappedName ||
                                    normalizeName(c.city_name) === normGov
                                );
                                layer.setStyle({ fillOpacity: 0.8, weight: 3, color: '#fff' });

                                const content = city ? `
                                    <div style="text-align:left; min-width:160px;">
                                        <b style="color:${getTempColor(city.temperature)}; font-size:1.1em; border-bottom:1px solid #333; display:block; margin-bottom:5px; padding-bottom:2px;">${mappedName.toUpperCase()} GOV</b>
                                        <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span>MET_TEMP:</span> <b style="color:#fff;">${Math.round(city.temperature)}°C</b></div>
                                        <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span>HUMIDITY:</span> <b style="color:#fff;">${Math.round(city.humidity)}%</b></div>
                                        <div style="display:flex; justify-content:space-between; margin-bottom:2px;"><span>WIND_SPD:</span> <b style="color:#fff;">${Math.round(city.windspeed)}km/h</b></div>
                                        <div style="display:flex; justify-content:space-between;"><span>BARO_PRES:</span> <b style="color:#fff;">${Math.round(city.pressure)}hPa</b></div>
                                        <div style="font-size:0.6rem; color:#666; margin-top:5px; border-top:1px solid #222; padding-top:3px;">STATUS: LINK_ACTIVE</div>
                                    </div>
                                ` : `
                                    <div style="text-align:left; min-width:140px;">
                                        <b style="color:#555; border-bottom:1px solid #222; display:block; margin-bottom:5px;">${mappedName}</b>
                                        <span style="color:#444;">NO SENSOR UPLINK</span>
                                    </div>
                                `;

                                layer.bindTooltip(content, { sticky: true, className: 'tactical-tooltip', direction: 'top', offset: [0, -10] }).openTooltip();
                            },
                            mouseout: (e) => {
                                const city = lastData.find(c =>
                                    c.city_name === mappedName ||
                                    normalizeName(c.city_name) === normGov
                                );
                                layer.setStyle({
                                    fillOpacity: city ? 0.4 : 0.05,
                                    weight: city ? 2 : 1,
                                    color: city ? '#fff' : '#333'
                                });
                                layer.closeTooltip();
                            },
                            click: (e) => {
                                const city = lastData.find(c =>
                                    c.city_name === mappedName ||
                                    normalizeName(c.city_name) === normGov
                                );
                                if (city) selectCity(city);
                            }
                        });

                        // Store for wind engine
                        if (windEngine) windEngine.govLayers[mappedName] = layer;
                        if (windEngine && normGov === "mukalla") windEngine.govLayers["Mukalla"] = layer;
                        if (windEngine && mappedName === "Sana'a") windEngine.govLayers["Sana'a"] = layer;
                    }
                }).addTo(map);

                if (!windEngine) {
                    windEngine = new WindEngine(map);
                    // Repopulate if created after layer load
                    geoLayer.eachLayer(l => {
                        const name = NAME_MAP[l.feature.properties.shapeName] || l.feature.properties.shapeName;
                        windEngine.govLayers[name] = l;
                    });
                }
            } catch (e) {
                console.error("MAP_GEO_ERR", e);
                // Fallback: If GeoJSON fails, the map will still show tiles and markers.
            }
        }

        let lastData = [];

        async function update() {
            try {
                const res = await fetch('/api/weather');
                const data = await res.json();
                lastData = data.current;

                document.getElementById('api-error').style.display = 'none';
                document.getElementById('sync-tag').innerText = 'SECURE LINK ACTIVE // ' + data.server_time;

                if (!selectedId && data.current.length > 0) selectedId = data.current[0].location_id;

                if (!map) {
                    await initMap();
                } else if (geoLayer) {
                    geoLayer.setStyle(feature => {
                        const govName = feature.properties.shapeName;
                        const mappedName = NAME_MAP[govName] || govName;
                        const normGov = normalizeName(govName);
                        const city = lastData.find(c =>
                            c.city_name === mappedName ||
                            normalizeName(c.city_name) === normGov
                        );
                        return {
                            fillColor: city ? getTempColor(city.temperature) : '#111',
                            weight: city ? 2.5 : 1,
                            color: city ? '#fff' : '#333',
                            fillOpacity: city ? 0.6 : 0.05
                        };
                    });
                }

                if (windEngine) windEngine.update(data.current);

                renderSidebar(data.current);
                renderStats(data.current);

                // Ensure history is at least partially populated for the visual even if empty on server
                let historyData = data.history || [];
                if (historyData.length === 0 && data.current.length > 0 && typeof luxon !== 'undefined') {
                    // Create a simulated 3-hour history if server returns none
                    historyData = [];
                    data.current.forEach(c => {
                        for (let i = 0; i < 4; i++) {
                            historyData.push({
                                city_name: c.city_name,
                                temperature: c.temperature + (Math.random() - 0.5),
                                observation_time: luxon.DateTime.now().minus({ minutes: i * 60 }).toISO()
                            });
                        }
                    });
                }

                if (data.current && data.current.length > 0) {
                    renderVisuals(data.current, historyData);
                    updateMarkers(data.current);
                }

            } catch (e) {
                console.error("DASHBOARD_UPDATE_ERR", e);
                document.getElementById('api-error').style.display = 'block';
                document.getElementById('sync-tag').innerText = 'SECURE LINK FAILURE';
            }
        }

        function renderSidebar(cities) {
            const list = document.getElementById('city-sidebar');
            list.innerHTML = '';
            cities.forEach(c => {
                const div = document.createElement('div');
                div.className = `city-item ${c.location_id === selectedId ? 'active' : ''}`;
                div.onclick = () => { selectCity(c); };
                div.innerHTML = `<span>${c.city_name}</span><span style="color:var(--accent);">${Math.round(c.temperature || 0)}°</span>`;
                list.appendChild(div);
            });
        }

        function selectCity(city) {
            selectedId = city.location_id;
            map.flyTo([city.latitude, city.longitude], 8, { duration: 1.2 });
            update();
        }

        function updateMarkers(cities) {
            cities.forEach(c => {
                if (markers[c.location_id]) {
                    markers[c.location_id].setLatLng([c.latitude, c.longitude]);
                } else {
                    const icon = L.divIcon({ className: 'leaflet-div-icon', html: '<div class="marker-pulse"></div>' });
                    markers[c.location_id] = L.marker([c.latitude, c.longitude], { icon }).addTo(map)
                        .on('click', () => selectCity(c));
                }
            });
        }

        function renderStats(cities) {
            const c = cities.find(x => x.location_id === selectedId) || cities[0];
            if (!c) return;
            document.getElementById('st-temp').innerText = Math.round(c.temperature || 0) + '°C';
            document.getElementById('st-hum').innerText = Math.round(c.humidity || 0) + '%';
            document.getElementById('st-pres').innerText = Math.round(c.pressure || 0) + ' hPa';
            document.getElementById('st-vis').innerText = (c.visibility / 1000).toFixed(1) + 'km';
        }

        function renderVisuals(current, history) {
            if (!current || current.length === 0) return;
            const sel = current.find(x => x.location_id === selectedId) || current[0];
            if (!sel) return;

            // 1. Radar
            const radarData = {
                labels: ['Heat', 'Wind', 'Hum', 'Cloud', 'UV'],
                datasets: [{
                    label: sel.city_name,
                    data: [sel.temperature, sel.windspeed, sel.humidity, sel.cloud_cover, sel.uv_index * 10],
                    backgroundColor: 'rgba(0, 255, 255, 0.15)',
                    borderColor: '#00ffff', borderWidth: 2
                }]
            };
            draw('radarChart', 'radar', radarData, { scales: { r: { grid: { color: '#222' }, angleLines: { color: '#222' }, ticks: { display: false } } } });

            // 2. UV Polar Chart
            const polarData = {
                labels: current.slice(0, 6).map(x => x.city_name),
                datasets: [{
                    label: 'UV Index',
                    // Add a baseline of 0.5 so segments are visible even when UV is 0 (Night Mode)
                    data: current.slice(0, 6).map(x => Math.max(x.uv_index || 0, 0.5)),
                    backgroundColor: [
                        'rgba(255, 0, 255, 0.4)',
                        'rgba(255, 165, 0, 0.4)',
                        'rgba(0, 255, 255, 0.4)',
                        'rgba(255, 255, 0, 0.4)',
                        'rgba(0, 255, 0, 0.4)',
                        'rgba(0, 0, 255, 0.4)'
                    ],
                    borderColor: 'rgba(255, 255, 255, 0.2)',
                    borderWidth: 1
                }]
            };
            draw('polarChart', 'polarArea', polarData, {
                scales: {
                    r: {
                        grid: { color: '#1a1a1a' },
                        angleLines: { color: '#1a1a1a' },
                        suggestedMax: 10,
                        ticks: { display: false }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `UV_INDEX: ${current[context.dataIndex].uv_index}`
                        }
                    }
                }
            });

            // 3. Bar
            const barLabels = current.slice(0, 8).map(x => x.city_name);
            const barData = {
                labels: barLabels,
                datasets: [{ label: 'Cloud Cover %', data: current.slice(0, 8).map(x => x.cloud_cover), backgroundColor: 'rgba(0,255,255,0.7)' }]
            };
            draw('barChart', 'bar', barData, { indexAxis: 'y', scales: { x: { grid: { color: '#111' } }, y: { grid: { display: false } } } });

            // 4. Line
            const historyNames = [...new Set(history.map(h => h.city_name))];
            const displayCities = historyNames.length > 0 ? historyNames.slice(0, 4) : current.slice(0, 4).map(c => c.city_name);

            const lineData = {
                datasets: displayCities.map((name, i) => {
                    const cityHistory = history.filter(h => h.city_name === name);
                    return {
                        label: name,
                        data: cityHistory.map(h => ({ x: h.observation_time, y: h.temperature })),
                        borderColor: ['#0ff', '#f0f', '#0f0', '#ff0'][i],
                        borderWidth: 2,
                        pointRadius: 2,
                        tension: 0.3,
                        showLine: cityHistory.length > 1
                    };
                })
            };

            draw('lineChart', 'line', lineData, {
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'hour', displayFormats: { hour: 'HH:mm' } },
                        min: luxon.DateTime.now().minus({ hours: 3 }).toISO(),
                        max: luxon.DateTime.now().toISO(),
                        grid: { color: '#111' },
                        ticks: { color: '#444', font: { size: 9 } }
                    },
                    y: {
                        grid: { color: '#111' },
                        ticks: { color: '#444', font: { size: 9 } }
                    }
                },
                plugins: {
                    legend: { display: true, labels: { boxWidth: 10, font: { size: 10 } } }
                }
            });
        }

        function draw(id, type, data, options) {
            if (instances[id]) {
                instances[id].data = data;
                instances[id].update('none');
            } else {
                const ctx = document.getElementById(id).getContext('2d');
                instances[id] = new Chart(ctx, {
                    type: type, data: data,
                    options: { ...options, responsive: true, maintainAspectRatio: false, animation: { duration: 0 } }
                });
            }
        }

        setInterval(update, 3000); // 3 sec heartbeat
        window.onload = () => {
            update();
            initDrawer();
        };

        // DRAWER CONTROLS
        function initDrawer() {
            const drawer = document.getElementById('drawer');
            const overlay = document.getElementById('drawer-overlay');
            const toggle = document.getElementById('drawer-toggle');
            const close = document.getElementById('drawer-close');

            if (!drawer || !overlay || !toggle || !close) return;

            function toggleDrawer() {
                drawer.classList.toggle('active');
                overlay.classList.toggle('active');
            }

            toggle.onclick = toggleDrawer;
            close.onclick = toggleDrawer;
            overlay.onclick = toggleDrawer;
        }
    </script>
</body>

</html>